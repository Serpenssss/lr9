CREATE TABLE врачи (
    id_врача SERIAL PRIMARY KEY,
    фамилия VARCHAR(50) NOT NULL,
    имя VARCHAR(50),
    отчество VARCHAR(50),
    специальность VARCHAR(100) NOT NULL,
    стоимость_приема DECIMAL(10, 2) NOT NULL,
    процент_отчислений DECIMAL(5, 2) NOT NULL CHECK (процент_отчислений BETWEEN 0 AND 100)
);

CREATE TABLE пациенты (
    id_пациента SERIAL PRIMARY KEY,
    фамилия VARCHAR(50) NOT NULL,
    имя VARCHAR(50),
    отчество VARCHAR(50),
    дата_рождения DATE,
    адрес TEXT
);

CREATE TABLE приемы (
    id_приема SERIAL PRIMARY KEY,
    id_врача INT REFERENCES врачи(id_врача),
    id_пациента INT REFERENCES пациенты(id_пациента),
    дата_приема DATE NOT NULL,
    стоимость_приема DECIMAL(10, 2) NOT NULL
);

CREATE TABLE платежи (
    id_платежа SERIAL PRIMARY KEY,
    id_приема INT REFERENCES приемы(id_приема),
    сумма DECIMAL(10, 2) NOT NULL,
    дата_оплаты TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE зарплаты_врачей (
    id_начисления SERIAL PRIMARY KEY,
    id_врача INT REFERENCES врачи(id_врача),
    id_приема INT REFERENCES приемы(id_приема),
    брутто_зарплата DECIMAL(10, 2),
    нетто_зарплата DECIMAL(10, 2)
);

CREATE OR REPLACE FUNCTION calculate_salary() RETURNS TRIGGER AS $$
BEGIN
    NEW.брутто_зарплата := (SELECT стоимость_приема FROM приемы WHERE id_приема = NEW.id_приема) * (SELECT процент_отчислений FROM врачи WHERE id_врача = NEW.id_врача) / 100;
    NEW.нетто_зарплата := NEW.брутто_зарплата - NEW.брутто_зарплата * 0.13;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_calculate_salary
BEFORE INSERT ON зарплаты_врачей
FOR EACH ROW
EXECUTE FUNCTION calculate_salary();

INSERT INTO врачи (id_врача, фамилия, имя, отчество, специальность, стоимость_приема, процент_отчислений)
VALUES
(1, 'Иванов', 'Иван', 'Иванович', 'Терапевт', 1500.00, 15.00),
(2, 'Петров', 'Петр', 'Петрович', 'Хирург', 2000.00, 25.00),
(3, 'Сидоров', 'Сергей', 'Сергеевич', 'Кардиолог', 2500.00, 30.00),
(4, 'Кузнецова', 'Анна', 'Владимировна', 'Невролог', 1800.00, 18.00),
(5, 'Орлова', 'Ольга', 'Николаевна', 'Офтальмолог', 1700.00, 17.00),
(6, 'Васильев', 'Алексей', 'Викторович', 'Ортопед', 1900.00, 19.00),
(7, 'Федорова', 'Елена', 'Павловна', 'Эндокринолог', 2100.00, 21.00),
(8,  'Александров', 'Андрей', 'Андреевич', 'Уролог', 2200.00, 22.00),
(9, 'Захарова', 'Марина', 'Геннадьевна', 'Дерматолог', 1600.00, 16.00),
(10, 'Комаров', 'Дмитрий', 'Валерьевич', 'Психиатр', 2300.00, 23.00),
(11, 'Никитин', 'Николай', 'Александрович', 'Онколог', 2400.00, 24.00),
(12, 'Попова', 'Светлана', 'Борисовна', 'Педиатр', 1400.00, 14.00),
(13, 'Романова', 'Наталья', 'Вячеславовна', 'Гастроэнтеролог', 1950.00, 19.50),
(14, 'Семенов', 'Максим', 'Игоревич', 'Отоларинголог', 1850.00, 18.50),
(15, 'Тимофеева', 'Инна', 'Константиновна', 'Рентгенолог', 1750.00, 17.50),
(16, 'Устинова', 'Дарья', 'Артемовна', 'Гинеколог', 2050.00, 20.50),
(17, 'Филатова', 'Татьяна', 'Михайловна', 'Аллерголог', 1650.00, 16.50),
(18, 'Чернова', 'Екатерина', 'Георгиевна', 'Реабилитолог', 1550.00, 15.50),
(19, 'Шишкин', 'Александр', 'Витальевич', 'Физиотерапевт', 1450.00, 14.50),
(20, 'Яковлев', 'Владимир', 'Евгеньевич', 'Диетолог', 1350.00, 13.50);

INSERT INTO пациенты (id_пациента, фамилия, имя, отчество, дата_рождения, адрес) 
VALUES
(1, 'Иванов', 'Иван', 'Иванович', '1980-01-05', 'Москва, ул. Тверская, д. 12'),
(2, 'Петров', 'Петр', 'Петрович', '1990-02-10', 'Санкт-Петербург, пр-т Невский, д. 34'),
(3, 'Сидоров', 'Сергей', 'Сергеевич', '1975-03-15', 'Новосибирск, ул. Красный проспект, д. 56'),
(4, 'Кузнецова', 'Анна', 'Владимировна', '1985-04-20', 'Екатеринбург, ул. Малышева, д. 78'),
(5, 'Орлова', 'Ольга', 'Александровна', '1995-05-25', 'Казань, ул. Баумана, д. 9'),
(6, 'Васильев', 'Алексей', 'Николаевич', '1960-06-30', 'Нижний Новгород, ул. Большая Покровская, д. 21'),
(7, 'Федорова', 'Марина', 'Павловна', '1970-07-14', 'Самара, ул. Молодогвардейская, д. 43'),
(8, 'Комаров', 'Дмитрий', 'Валерьевич', '1986-08-27', 'Омск, ул. Маркса, д. 65'),
(9, 'Зайцева', 'Елена', 'Викторовна', '1991-09-11', 'Ростов-на-Дону, ул. Пушкинская, д. 87'), 
(10, 'Романова', 'Светлана', 'Георгиевна', '1965-10-19', 'Краснодар, ул. Красная, д. 32'),
(11, 'Леонова', 'Наталья', 'Игоревна', '1983-11-22', 'Челябинск, пр-т Ленина, д. 54'),
(12, 'Миронов', 'Михаил', 'Андреевич', '1993-12-03', 'Волгоград, ул. Мира, д. 76'),
(13, 'Соколова', 'Татьяна', 'Евгеньевна', '1955-01-17', 'Пермь, ул. Ленина, д. 98'),
(14, 'Семенов', 'Владимир', 'Борисович', '1940-02-29', 'Воронеж, ул. Карла Маркса, д. 111'),
(15, 'Павлова', 'Инна', 'Геннадьевна', '1978-03-28', 'Красноярск, ул. Мира, д. 123'),
(16, 'Григорьева', 'Юлия', 'Антоновна', '1997-04-16', 'Саратов, ул. Советская, д. 135'),
(17, 'Попов', 'Александр', 'Владимирович', '1989-05-26', 'Тюмень, ул. Республики, д. 147'),
(18, 'Максимова', 'Оксана', 'Анатольевна', '1967-06-07', 'Барнаул, ул. Ленина, д. 159'),
(19, 'Степанов', 'Артем', 'Михайлович', '1999-07-18', 'Ижевск, ул. Пушкинская, д. 171'),
(20, 'Ковалева', 'Полина', 'Денисовна', '1982-08-29', 'Иркутск, ул. Байкальская, д. 183');

INSERT INTO приемы (id_врача, id_пациента, дата_приема, стоимость_приема) VALUES
(1, 15, '2023-10-26', 1500.00),
(2, 3, '2023-10-27', 2000.00),
(3, 7, '2023-10-28', 2500.00),
(4, 12, '2023-10-29', 1800.00),
(5, 14, '2023-10-30', 1700.00),
(6, 8, '2023-10-31', 1900.00),
(7, 19, '2023-11-01', 2100.00),
(8, 4, '2023-11-02', 2200.00),
(9, 2, '2023-11-03', 1600.00),
(10, 12, '2023-11-04', 2300.00),
(11, 13, '2023-11-05', 2400.00),
(12, 9, '2023-11-06', 1400.00),
(13, 17, '2023-11-07', 1950.00),
(14, 10, '2023-11-08', 1850.00),
(15, 6, '2023-11-09', 1750.00),
(16, 5, '2023-11-10', 2050.00),
(17, 1, '2023-11-11', 1650.00),
(18, 10, '2023-11-12', 1550.00),
(19, 5, '2023-11-13', 1450.00),
(20, 11, '2023-11-14', 1350.00),
(1, 20, '2023-11-15', 1500.00),
(2, 14, '2023-11-16', 2000.00),
(3, 8, '2023-11-17', 2500.00),
(4, 3, '2023-11-18', 1800.00),
(5, 16, '2023-11-19', 1700.00);

INSERT INTO платежи (id_приема, сумма, дата_оплаты) VALUES
(1, 1500.00, '2023-10-01 08:00:00'),
(2, 2000.00, '2023-10-02 08:15:00'),
(3, 2500.00, '2023-10-03 08:30:00'),
(4, 1800.00, '2023-10-04 08:45:00'),
(5, 1700.00, '2023-10-05 09:00:00'),
(6, 1900.00, '2023-10-06 09:15:00'),
(7, 2100.00, '2023-10-07 09:30:00'),
(8, 2200.00, '2023-10-08 09:45:00'),
(9, 1600.00, '2023-10-09 10:00:00'),
(10, 2300.00, '2023-10-10 10:15:00'),
(11, 2400.00, '2023-10-11 10:30:00'),
(12, 1400.00, '2023-10-12 10:45:00'),
(13, 1950.00, '2023-10-13 11:00:00'),
(14, 1850.00, '2023-10-14 11:15:00'),
(15, 1750.00, '2023-10-15 11:30:00'),
(16, 2050.00, '2023-10-16 11:45:00'),
(17, 1650.00, '2023-10-17 12:00:00'),
(18, 1550.00, '2023-10-18 12:15:00'),
(19, 1450.00, '2023-10-19 12:30:00'),
(20, 1350.00, '2023-10-20 12:45:00'),
(21, 1500.00, '2023-10-21 13:00:00'),
(22, 2000.00, '2023-10-22 13:15:00'),
(23, 2500.00, '2023-10-23 13:30:00'),
(24, 1800.00, '2023-10-24 13:45:00'),
(25, 1700.00, '2023-10-25 14:00:00');

INSERT INTO зарплаты_врачей (id_врача, id_приема) VALUES
(1, 1),
(2, 2),
(3, 3),
(4, 4),
(5, 5),
(6, 6),
(7, 7),
(8, 8),
(9, 9),
(10, 10),
(11, 11),
(12, 12),
(13, 13),
(14, 14),
(15, 15),
(16, 16),
(17, 17),
(18, 18),
(19, 19),
(20, 20),
(1, 21),
(2, 22),
(3, 23),
(4, 24),
(5, 25);

SELECT --7й скрипт
    v.фамилия, 
    v.имя, 
    v.отчество, 
    SUM(p.стоимость_приема) AS общая_стоимость_приемов
FROM 
    врачи v
JOIN 
    приемы p ON v.id_врача = p.id_врача
GROUP BY 
    v.фамилия, v.имя, v.отчество, v.id_врача;
    --Этот запрос выбирает фамилии, имена, отчества врачей и общую стоимость их приемов. Для этого используется соединение таблиц врачи и приемы, 
    --чтобы объединить данные о врачах и их приемах. Затем результат группируется по каждому врачу (по его ФИО и идентификатору), а функция SUM() суммирует стоимости всех приемов каждого врача.
--Составляющие:

--SELECT: выбираются столбцы v.фамилия, v.имя, v.отчество и вычисляемый столбец SUM(p.стоимость_приема) с псевдонимом общая_стоимость_приемов.
--FROM: задается таблица врачи с псевдонимом v.
--JOIN: выполняется соединение таблицы врачи с таблицей приемы по полю id_врача. Это позволяет связать информацию о враче с информацией о его приемах.
--ON: условие соединения таблиц — совпадение полей v.id_врача и p.id_врача.
--GROUP BY: группировка результатов по фамилиям, именам, отчествам и идентификаторам врачей, чтобы суммировать стоимость приемов отдельно для каждого врача.

SELECT --8й скрипт
    v.фамилия, 
    v.имя, 
    v.отчество, 
    SUM(p.стоимость_приема) AS общая_стоимость_приемов
FROM 
    врачи v
JOIN 
    приемы p ON v.id_врача = p.id_врача
GROUP BY 
    v.фамилия, v.имя, v.отчество, v.id_врача
ORDER BY 
    SUM(p.стоимость_приема) DESC;
--Запрос аналогичен предыдущему, но добавляет сортировку результата по общей стоимости приемов в порядке убывания (DESC), то есть сначала будут показаны врачи с наибольшей суммарной стоимостью приемов.
--Составляющие:
--ORDER BY: добавлен новый элемент, который сортирует результаты по убыванию суммы стоимостей приемов (SUM(p.стоимость_приема)).

SELECT --9й скрипт
    v.фамилия, 
    v.имя, 
    v.отчество, 
    ROUND(SUM(p.стоимость_приема)::NUMERIC, 2) AS общая_стоимость_приемов,
    ROUND(AVG(SUM(p.стоимость_приема)) OVER (), 2) AS средняя_общая_стоимость_приемов
FROM 
    врачи v
JOIN 
    приемы p ON v.id_врача = p.id_врача
GROUP BY 
    v.фамилия, v.имя, v.отчество, v.id_врача
ORDER BY 
    SUM(p.стоимость_приема) DESC;
--Запрос похож на предыдущие, но дополнительно выводит среднюю общую стоимость приемов среди всех врачей. Используются функции округления ROUND() для приведения значений к двум десятичным знакам.
--Составляющие:

--ROUND(SUM(p.стоимость_приема)::NUMERIC, 2): округляет сумму стоимостей до двух знаков после запятой.
--ROUND(AVG(SUM(p.стоимость_приема)) OVER (), 2): вычисляет среднее значение общей стоимости приемов среди всех врачей и также округляет его до двух знаков.

WITH patient_totals AS (--10й скрипт
    SELECT 
        п.фамилия, 
        п.имя, 
        SUM(пр.стоимость_приема) AS общая_стоимость_приемов
    FROM 
        пациенты п
    JOIN 
        приемы пр ON п.id_пациента = пр.id_пациента
    GROUP BY 
        п.фамилия, п.имя, п.id_пациента
)
SELECT *
FROM patient_totals
ORDER BY общая_стоимость_приемов DESC
LIMIT 1;
--В этом запросе используется оператор WITH для создания временной таблицы patient_totals, которая содержит фамилию, имя пациента и общую стоимость его приемов. 
--Основная часть запроса затем выбирает данные из этой временной таблицы, сортируя их по общей стоимости приемов в порядке убывания и ограничивая выборку одним пациентом с максимальной общей стоимостью приемов.
--Составляющие:

--WITH patient_totals AS ...: создает временную таблицу patient_totals, содержащую информацию о пациентах и сумме их приемов.
--SELECT * FROM patient_totals: выбирает все строки из временной таблицы.
--ORDER BY общая_стоимость_приемов DESC: сортирует пациентов по общей стоимости их приемов в порядке убывания.
--LIMIT 1: оставляет только одного пациента с самой высокой общей стоимостью приемов.

WITH top_patient AS (--11й скрипт
    SELECT
        p.фамилия,
        p.имя,
        p.отчество,
        p.id_пациента
    FROM
        пациенты p
    INNER JOIN
        приемы pr ON p.id_пациента = pr.id_пациента
    GROUP BY
        p.фамилия, p.имя, p.отчество, p.id_пациента
    ORDER BY
        SUM(pr.стоимость_приема) DESC
    LIMIT 1
)
SELECT
    pr.id_приема,
    pr.стоимость_приема
FROM
    приемы pr
INNER JOIN
    top_patient tp ON pr.id_пациента = tp.id_пациента
ORDER BY
    pr.стоимость_приема ASC;

--Этот запрос использует оператор WITH для нахождения пациента с наибольшей общей стоимостью приемов. Затем основной запрос выбирает все приемы этого пациента, сортируя их по стоимости в порядке возрастания.
--Составляющие:

--WITH top_patient AS ...: создается временная таблица top_patient, содержащая информацию о пациенте с наибольшей общей стоимостью приемов.
--SELECT pr.id_приема, pr.стоимость_приема: выбирает идентификаторы и стоимости приемов данного пациента.
--INNER JOIN top_patient tp ON pr.id_пациента = tp.id_пациента: соединяет таблицу приемы с временной таблицей top_patient по идентификатору пациента.
--ORDER BY pr.стоимость_приема ASC: сортирует результаты по возрастанию стоимости приема.

WITH patient_totals AS (--12 скрипт
    SELECT 
        п.фамилия, 
        п.имя, 
        SUM(пр.стоимость_приема) AS общая_стоимость_приемов
    FROM 
        пациенты п
    JOIN 
        приемы пр ON п.id_пациента = пр.id_пациента
    GROUP BY 
        п.фамилия, п.имя, п.id_пациента
),
avg_cost AS (
    SELECT 
        ROUND(AVG(общая_стоимость_приемов)) AS средняя_стоимость_приемов
    FROM 
        patient_totals
)
SELECT 
    п.фамилия, 
    п.имя, 
    п.общая_стоимость_приемов, 
    ac.средняя_стоимость_приемов 
FROM 
    patient_totals п
CROSS JOIN 
    avg_cost ac
WHERE 
    п.общая_стоимость_приемов > ac.средняя_стоимость_приемов;

--Запрос использует два оператора WITH: первый создает временную таблицу patient_totals с данными о пациентах и общей стоимости их приемов, второй (avg_cost) вычисляет среднюю стоимость приемов среди всех пациентов. 
--Основной запрос затем выбирает тех пациентов, у которых общая стоимость приемов превышает эту среднюю стоимость.
--Составляющие:

--WITH patient_totals AS ...: создает временную таблицу patient_totals, содержащую информацию о пациентах и сумме их приемов.
--avg_cost AS ...: создает временную таблицу avg_cost, содержащую одну строку со средней стоимостью приемов.
--CROSS JOIN avg_cost ac: выполняет перекрестное соединение между таблицами patient_totals и avg_cost, чтобы каждая строка первой таблицы была связана с единственной строкой второй таблицы.
--WHERE п.общая_стоимость_приемов > ac.средняя_стоимость_приемов: фильтрует пациентов, оставляя только тех, чья общая стоимость приемов больше средней стоимости.